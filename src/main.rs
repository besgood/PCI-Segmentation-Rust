use clap::{Arg, Command};
use std::process::{Command as SysCommand};
use std::fs::{File, create_dir_all};
use std::io::{Write, BufRead, BufReader};
use std::collections::HashSet;
use std::path::Path;
use chrono::Local;

fn run_scan(tool: &str, targets: &[String], ports: &str, protocol: &str) -> Vec<String> {
    let joined_targets = targets.join(" ");
    let args = if tool == "masscan" {
        vec!["-p", ports, &joined_targets]
    } else {
        let scan_type = match protocol {
            "tcp" => "-sS",
            "udp" => "-sU",
            _ => "-sS",
        };
        vec!["-Pn", scan_type, "-p", ports, &joined_targets]
    };

    println!("Running {} scan on: {}", tool, joined_targets);

    let output = SysCommand::new(tool)
        .args(&args)
        .output()
        .expect("Failed to run scan tool");

    let result = String::from_utf8_lossy(&output.stdout).to_string();
    result.lines().map(|s| s.to_string()).collect()
}

fn load_targets(file_path: &str) -> Vec<String> {
    let file = File::open(file_path).expect("Could not open hostfile.");
    let reader = BufReader::new(file);
    reader.lines().filter_map(Result::ok).collect()
}

fn save_results(lines: &[String], output_path: &str) {
    let mut file = File::create(output_path).expect("Could not create output file.");
    for line in lines {
        writeln!(file, "{}", line).unwrap();
    }
}

fn main() {
    let matches = Command::new("PCI Segmentation Scanner")
        .version("1.0")
        .author("Generated by ChatGPT")
        .about("Performs PCI segmentation tests using Nmap or Masscan")
        .arg(Arg::new("hostfile").required(true).help("Path to file with target IPs"))
        .arg(Arg::new("ports").required(true).help("Port range to scan (e.g., 1-1000 or top-100)"))
        .arg(Arg::new("protocol").required(true).value_parser(["tcp", "udp"]).help("Protocol to scan"))
        .arg(Arg::new("tool").required(true).value_parser(["nmap", "masscan"]).help("Tool to use: nmap or masscan"))
        .arg(Arg::new("rate")
            .long("rate")
            .help("Set the Masscan packets per second rate")
            .takes_value(true)
            .default_value("1000"))
        .arg(Arg::new("output").required(true).help("Base name for output files"))
        .get_matches();

    let hostfile = matches.get_one::<String>("hostfile").unwrap();
    let ports = matches.get_one::<String>("ports").unwrap();
    let protocol = matches.get_one::<String>("protocol").unwrap();
    let tool = matches.get_one::<String>("tool").unwrap();
    let output = matches.get_one::<String>("output").unwrap();

    if protocol == "udp" && tool == "masscan" {
        println!("‚ö†Ô∏è  Warning: Masscan has limited UDP support.");
        println!("Continue anyway? (y/N): ");
        let mut confirm = String::new();
        std::io::stdin().read_line(&mut confirm).unwrap();
        if confirm.trim().to_lowercase() != "y" {
            println!("Aborting.");
            return;
        }
    }

    let targets = load_targets(hostfile);
    let results = run_scan(tool, &targets, ports, protocol);

    let timestamp = Local::now().format("%Y%m%d_%H%M%S").to_string();
    let out_file = format!("{}_scan_{}.txt", output, timestamp);
    save_results(&results, &out_file);
    let html_report = format!("{}_report.html", output);
    let excel_report = format!("{}_report.xlsx", output);
    generate_html_report(&results, &html_report);
    generate_excel_report(&results, &excel_report);
    let csv_report = format!("{}_report.csv", output);
    let json_report = format!("{}_report.json", output);
    generate_csv_report(&results, &csv_report);
    generate_json_report(&results, &json_report);



    println!("‚úÖ Scan complete. Results saved to {}", out_file);
}
// Additional imports for reporting
use calamine::{Xlsx, Writer, XlsxWriter, RangeDeserializerBuilder};
use std::fs::OpenOptions;
use std::collections::HashMap;

fn generate_html_report(results: &[String], path: &str) {
    let mut html = String::from("""
<!DOCTYPE html>
<html>
<head>
    <title>PCI Segmentation Report</title>
    <style>
        body { font-family: Arial; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h2>PCI Segmentation Scan Report</h2>
    <table>
        <tr><th>Scan Output</th></tr>
""");

    for line in results {
        html.push_str(&format!("<tr><td>{}</td></tr>", line));
    }

    html.push_str("</table></body></html>");

    let mut file = File::create(path).expect("Failed to write HTML report");
    file.write_all(html.as_bytes()).unwrap();
    println!("üìÑ HTML report written to {}", path);
}

fn generate_excel_report(results: &[String], path: &str) {
    let mut workbook = XlsxWriter::new();
    let mut sheet = workbook.add_worksheet(None).unwrap();

    for (i, line) in results.iter().enumerate() {
        sheet.write_string(i as u32, 0, line, None).unwrap();
    }

    let mut file = File::create(path).expect("Failed to write Excel report");
    workbook.close(&mut file).unwrap();
    println!("üìä Excel report written to {}", path);
}
use std::io::BufWriter;
use serde_json::json;
use std::collections::BTreeMap;

fn generate_csv_report(results: &[String], path: &str) {
    let file = File::create(path).expect("Failed to write CSV report");
    let mut writer = BufWriter::new(file);
    for line in results {
        writeln!(writer, ""{}"", line.replace('"', """")).unwrap();
    }
    println!("üßæ CSV report written to {}", path);
}

fn generate_json_report(results: &[String], path: &str) {
    let json_results: Vec<_> = results.iter().map(|line| {
        let mut map = BTreeMap::new();
        map.insert("result", line);
        json!(map)
    }).collect();

    let json_output = json!(json_results);
    let mut file = File::create(path).expect("Failed to write JSON report");
    write!(file, "{}", json_output.to_string()).unwrap();
    println!("üìÑ JSON report written to {}", path);
}
